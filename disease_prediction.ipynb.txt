# purpose: Evaluate the performance of a pneumonia detection model using key mertics.

# Import necessary libraries 
from sklearn.mertices import accuracy_score, precision_score, recall_score,f1_score
import numpy as np

# Sample dataset: True labels and predicted labels
# 1 represents pneumonia,0 representn non-pneumonia
true_labels = np.array([1,0,1,0,1,0,1,0,1,0])
predicted_labels = np.array([1,0,1,0,1,0,1,0,1,0])

# calculate accuracy 
accuracy = accuracy_score(true_labels, predicted_labels)
print(f"Accuracy:{accuracy:.2f}") # Execute to see the accuracy of the model 

# calculate precision 
precision = precision_score(true_labels, predicted_labels)
print (f"precision:{precision:.2f}") # Execute to see the precision of the model 

# calculate Recall 
recall = recall_score(true_labels, predicted_labels)
print(f"Recall:{recall:.2f}") # Execute to see the recall of the model 

# calculate F1-score 
f1 = f1_score(true_labels,predicted _labels)
print (f"F1 score:{f1:.2f}") # Executed to see the F1 score of the model

# code optimisation suggestions:
# 1. use numpy arrays for efficient computation of large datasets.
# 2. modularize the code by creating functions for each Matric calculation.
# 3. add error handling to manage potential issues with input data. 

# example of modularization in error handling

def calculate_metrics(true_labels, predicted_labels):
try:
    accuracy = accuracy_score(true_labels, predicted_labels)
    precession = precision_score(true_labels, predicted_labels)
    recall = recall_score(true_labels, predicated_labels)
    f1 = f1_score(true_labels, predicted_labels)
    return accuracy, precision, recall, f1 
expect exception as e:
  print(f"An error occured: {e}")
  return None,None,None,None

# call the function and print results 
accuracy, precision,recall,f1 = calculate_metrices(true_labels, predicted_labels)
print(f"Accuracy: {accuracy:.2f}, precision:{precision:.2f},
recall: {recall:2f}, {F1:.2f}") # Execute to see all metrics 
